// Generated by CoffeeScript 1.4.0
(function() {

  define(['deps/under', 'deps/d3', 'lib/miscellaneous/graphics_2d/grid', 'lib/miscellaneous/turing_machine', 'lib/utilities/d3_helper'], function(underscore, d3, Grid, TM, d3_helper) {
    var center_square_nw_corner, h, middle_x, setup_tape, spacing, square_side, step, triangle, unit, unit_size, w, _;
    _ = underscore._;
    d3 = d3;
    unit_size = 20;
    h = screen.availHeight - 200;
    w = screen.availWidth - 50;
    step = 1000;
    unit = 40;
    spacing = 4;
    square_side = unit - spacing;
    middle_x = w / 2;
    center_square_nw_corner = {
      x: middle_x - (square_side / 2),
      y: spacing
    };
    triangle = [
      {
        x: middle_x,
        y: spacing * 2 + square_side
      }, {
        x: center_square_nw_corner.x,
        y: center_square_nw_corner.y + square_side * 2 + spacing
      }, {
        x: center_square_nw_corner.x + square_side,
        y: center_square_nw_corner.y + square_side * 2 + spacing
      }
    ];
    setup_tape = function(tape) {
      var curr, i, index, left, ls, n, num_extra_ls, num_extra_rs, num_ls, num_rs, offset, right, rs, sliced_ls, sliced_rs, square, _i, _j, _len, _len1;
      left = tape.left, curr = tape.curr, right = tape.right, index = tape.index;
      num_ls = Math.ceil((center_square_nw_corner.x / unit) + 1);
      num_rs = Math.ceil((w - (center_square_nw_corner.x + unit)) / unit + 1);
      num_extra_ls = num_ls - left.length;
      num_extra_rs = num_rs - right.length;
      if (num_extra_rs < 0) {
        num_extra_rs = 0;
      }
      if (num_extra_ls < 0) {
        num_extra_ls = 0;
      }
      ls = left.slice(0).concat((function() {
        var _i, _len, _ref, _results;
        _ref = _.range(0, num_extra_ls);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(new TM.Symbol.B());
        }
        return _results;
      })());
      rs = right.slice(0).concat((function() {
        var _i, _len, _ref, _results;
        _ref = _.range(0, num_extra_rs);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          _results.push(new TM.Symbol.B());
        }
        return _results;
      })());
      sliced_ls = ls.slice(0, num_ls - 1);
      sliced_rs = rs.slice(0, num_rs - 1);
      for (i = _i = 0, _len = sliced_ls.length; _i < _len; i = ++_i) {
        square = sliced_ls[i];
        square.index = index - (i + 1);
        square.offset = 0 - (i + 1);
      }
      for (i = _j = 0, _len1 = sliced_rs.length; _j < _len1; i = ++_j) {
        square = sliced_rs[i];
        square.index = index + i + 1;
        square - (offset = i + 1);
      }
      curr.index = index;
      curr.offset = 0;
      sliced_ls.reverse();
      return sliced_ls.concat([curr]).concat(sliced_rs);
    };
    return function() {
      var canvas, container, draw_head, draw_tape, draw_turing_machine;
      canvas = d3_helper.create_canvas(w, h);
      container = canvas.append("svg:g").classed("container", true);
      container.attr("fill", 'black');
      container.append("svg:g").classed("tape", true);
      container.append("svg:g").classed("head", true);
      draw_tape = function(tape) {
        var square, square_g, square_rect, square_text;
        tape = container.select("g.tape").data(setup_tape(tape));
        square = tape.selectAll("g.square").data(function(d) {
          return d.index;
        });
        square_g = square.enter().append("svg:g");
        square_rect = square_g.append("svg:rect").attr("width", square_side).attr("height", square_side).attr("fill", 'white');
        square_text = square_g.append("svg:text").attr("fill", 'orange').text(function(d) {
          return d.sym.show();
        });
        square.select("text").text(function(d) {
          return d.sym.show();
        });
        square.transition().attr("transform", function(d) {
          return d3_helper.transforms.translate(d.offset * unit + center_square_nw_corner.x, 0);
        });
        return square.exit().remove();
      };
      draw_head = function(state) {
        var head;
        head = container.select("g.head").data(state);
        head.enter().append("svg:polygon").attr("points", d3_helper.polygon(triangle)).attr("fill", 'aquamarine').append("svg:text").attr("fill", 'darkmagenta').text(function(d) {
          return d.show();
        });
        return head.select("text").text(function(d) {
          return d.show();
        });
      };
      draw_turing_machine = function(tm) {
        draw_tape(tm.tape);
        return draw_head(tm.state);
      };
      return draw_turing_machine({
        tape: [],
        state: new TM.State.H()
      });
    };
  });

}).call(this);
