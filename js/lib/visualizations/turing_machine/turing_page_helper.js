// Generated by CoffeeScript 1.4.0
(function() {
  var __hasProp = {}.hasOwnProperty;

  define(['deps/under', 'deps/d3', 'cs!lib/miscellaneous/turing_machine', 'cs!lib/visualizations/turing_machine/turing_parser', 'cs!lib/visualizations/turing_machine/turing_builder', 'lib/utilities/d3_helper'], function(underscore, d3, TM, parser, builder, d3_helper) {
    var parsed_tm_program, setup_rules, starting_tm, starting_tm_program, starting_tm_string, tm, _;
    _ = underscore._;
    d3 = d3;
    /*
        starting_tm_string = """
          Alphabet: S1
          States: q1, q2, q3
          q1: B  -> W(S1); q1
          q1: S1 -> L    ; q2
          q2: B  -> W(S1); q2
          q2: S1 -> L    ; q3
          q3: B  -> W(S1); q3
          q3: S1 -> H    ;
        """
    */

    starting_tm_string = "Alphabet: S1\nStates: q1, q2, q3, q4, q5\nq1: B -> R; q1\nq1: S1 -> R; q2\nq2: B -> W(S1); q3\nq2: S1 -> R; q2\nq3: B -> L; q4\nq3: S1 -> R; q3\nq4: B -> L; q5\nq4: S1 -> E; q4\nq5: S1 -> L; q5\nq5: B -> H;";
    parsed_tm_program = parser.parseTM(starting_tm_string);
    starting_tm_program = builder.builder(parsed_tm_program);
    starting_tm = new TM.TuringMachine(starting_tm_program);
    starting_tm.initialize(TM.State.create("q1"), [TM.Symbol.create("S1"), TM.Symbol.create("S1"), TM.Symbol.create("S1"), TM.Symbol.create("S1"), new TM.Symbol.B(), TM.Symbol.create("S1"), TM.Symbol.create("S1"), TM.Symbol.create("S1")]);
    tm = starting_tm;
    setup_rules = function(program) {
      var delta, instruction, rules, state, symbol;
      rules = [];
      for (state in program) {
        if (!__hasProp.call(program, state)) continue;
        instruction = program[state];
        for (symbol in instruction) {
          if (!__hasProp.call(instruction, symbol)) continue;
          delta = instruction[symbol];
          if (symbol !== "__state__") {
            rules.push({
              state: instruction.__state__,
              symbol: delta.__symbol__,
              delta: delta
            });
          }
        }
      }
      return rules;
    };
    return function(dimensions) {
      var action_spec, exported_names, halt_sign, left_arrow, points, reflect_over_half, reflection_over_x, right_arrow, spacing, square, square_side, template_spec, unit;
      unit = dimensions.unit, spacing = dimensions.spacing, square_side = dimensions.square_side;
      points = d3_helper.polygon;
      reflection_over_x = function(fixed_x) {
        return function(x) {
          return (2 * fixed_x) - x;
        };
      };
      reflect_over_half = reflection_over_x(square_side / 2);
      right_arrow = [
        {
          x: 0,
          y: square_side / 4
        }, {
          x: 0,
          y: 3 * square_side / 4
        }, {
          x: square_side / 2,
          y: 3 * square_side / 4
        }, {
          x: square_side / 2,
          y: square_side
        }, {
          x: square_side,
          y: square_side / 2
        }, {
          x: square_side / 2,
          y: 0
        }, {
          x: square_side / 2,
          y: square_side / 4
        }
      ];
      left_arrow = _.map(right_arrow, function(point) {
        var flipped_x, x, y;
        x = point.x, y = point.y;
        flipped_x = reflect_over_half(x);
        return {
          x: flipped_x,
          y: y
        };
      });
      halt_sign = [
        {
          x: 0,
          y: 0
        }, {
          x: 0,
          y: square_side
        }, {
          x: square_side / 4,
          y: square_side
        }, {
          x: square_side / 4,
          y: 5 * square_side / 8
        }, {
          x: 3 * square_side / 4,
          y: 5 * square_side / 8
        }, {
          x: 3 * square_side / 4,
          y: square_side
        }, {
          x: square_side,
          y: square_side
        }, {
          x: square_side,
          y: 0
        }, {
          x: 3 * square_side / 4,
          y: 0
        }, {
          x: 3 * square_side / 4,
          y: 3 * square_side / 8
        }, {
          x: square_side / 4,
          y: 3 * square_side / 8
        }, {
          x: square_side / 4,
          y: 0
        }
      ];
      square = [
        {
          x: 0,
          y: 0
        }, {
          x: square_side,
          y: 0
        }, {
          x: square_side,
          y: square_side
        }, {
          x: 0,
          y: square_side
        }
      ];
      template_spec = function() {
        return {
          polygon: {
            points: points(square),
            fill: 'white',
            visibility: 'visible'
          },
          text: {
            x: spacing,
            y: square_side - spacing,
            fill: 'lightcoral',
            visibility: 'hidden',
            text: ""
          }
        };
      };
      action_spec = function(d) {
        var t;
        t = template_spec();
        switch (d.delta.action.type()) {
          case "Erase":
            t;

            break;
          case "Write":
            t.text.visibility = 'visible';
            t.text.text = d.delta.action.sym.blank() ? "" : d.delta.action.sym.show();
            break;
          case "Left":
            t.polygon.points = points(left_arrow);
            t.polygon.fill = 'steelblue';
            break;
          case "Right":
            t.polygon.points = points(right_arrow);
            t.polygon.fill = 'steelblue';
            break;
          case "Halt":
            t.polygon.points = points(halt_sign);
            t.polygon.fill = 'crimson';
        }
        return t;
      };
      exported_names = {
        tm: tm,
        setup_rules: setup_rules,
        action_spec: action_spec
      };
      return exported_names;
    };
  });

}).call(this);
